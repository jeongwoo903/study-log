# [CS] 데이터 중심 설계와 객체지향

## 설계의 대분류
설계를 크게 2가지의 원칙으로 나누자면 아래와 같다.
1. CPU의 작업 시간을 중심으로 한 **성능(계산) 중심 설계**
2. 데이터(처리, 양, 속도) 중심으로 한 **데이터 중심 설계**

## 소프트웨어 시스템의 3가지의 핵심 키워드
시스템을 설계할 때 고려해야 할 요소 
1. **Reliability(신뢰성)**
   - 시스템은 어느 상황에서도 항상 잘 동작해야함.
   - The system should continue to work correctly. even in the face of adversity
2. **Scalacbility(확장성)**
   - 시스템의 규모가 커짐에 따라서, 이를 합리적으로 핸들링 할 수 있는 방법이 필요하다.
   - As the system grows, there should be reasonable ways of dealing with that growth.
3. **Maintainability(유지 보수성)**
   - 시스템을 운용하는 모든 엔지니어들이 생산적으로 작업할 수 있어야 한다.
   - Over time, many different people will work on the system, and they should all be able to work on it productively.

## 데이터 중심 설계와 객체지향(OOP) 설계의 시너지
- 객체지향 설계는 데이터와 행동(목적)을 하나의 단위로 묶는 객체를 중심으로 합니다.
  - 즉, 객체지향의 목표는 **데이터(변수)와 메서드(함수)를 하나로 묶어서 관리**하는 것.
- 이 두 가지를 결합하면 시스템의 데이터 구조와 비즈니스 로직이 일치하게 되어 유지보수와 확장이 용이해진다.

## 객체란 무엇인가
- 쉬운 접근 -> 사물. 사람. 고양이. 붕어빵... 등등.
- 모델링 관점 -> 명확한 의미를 담고 있는 대상 또는 개념.
- 객체지향 관점 -> 클래스 내에 변수와 메소드를 정의하는 것.

## 객체지향 프로그래밍 나오게 된 스토리
### 순차지향 프로그래밍
먼먼 옛날 프로그래밍은 순차적으로 이루어졌다. C가 대표적으로 그러하다.  
이는 즉, 프로그램은 위에서 아래로 짜여진 순서대로 진행되었다는 뜻이다.

어느날 사람들은 프로그래밍을 하다가 이전에 만들어 둔 것과 동일한 작업이 필요한 경우가 생기게 되었다.  
for, while과 같은 반복문을 통해 문제를 일부 해소할 수 있었지만, 코드가 종료되는 시점에서 반복이 필요한 경우 문제가 되었다.  
그래서 `goto()`와 같은 문법이 등장하였다.

하지만 `goto()`와 같이 흐름을 강제로 이동시키는 문법은 코드의 규모가 커지게 된다면 흐름을 파악하기 어렵고 스파게티 코드를 만들게 된다.

### 절차지향 프로그래밍 등장
사람들은 강제로 흐름을 제어하는 것에 문제를 느끼게 되었다.
그래서 반복되는 코드를 따로 빼서 만들어 두고 이 코드를 호출하여 사용한 후 다시 원래의 자리로 돌아오는 방식을 생각하게 되었고, 이를 `함수`라는 개념으로 사용하면서 절차지향 프로그래밍이 등장하게 되었다.

즉, 절차지향 프로그래밍은 **데이터를 처리하는 동작을 함수 단위로 분리하고 재사용하는 형태로 프로그래밍 하는 방식**이다.

### 절차지향 프로그래밍 한계
언제나 문제는 코드의 덩치가 커질때 발생한다.

절차지향적 프로그래밍은 기본적으로 변수를 전역변수의 형태로 선언한다.
그렇기에, 만약 동일한 이름의 변수를 써야한다고 한다면 어떻게든 구별하기 위해 아래와 같은 형식이 될 것이다.
ex) cat_A, cat_B

### namespace의 등장
namespace는 전역변수에서 충돌나는 하나의 파일 단위, 혹은 모듈 단위로 구별하여 변수와 함수들을 관리하기 위해 등장하였다.
하지만 namespace 또한 단점이 있었는데, 비슷한 구조의 형태를 가지는 변수를 만들땐 여전히 prefix를 붙여 만들어야 했다.
```text
// File1과 File2의 counter는 별개임.
namespace File1 {
    int counter;
}

namespace File2 {
    int counter;
}

// 그러나 비슷한 변수를 같은 네임스페이스 내에서 사용할 때
namespace Character {
    int user1_name;
    int user1_hp;
    int user1_mp;  // 여전히 prefix를 사용해 변수 이름을 구분
}
```
이런식으로 프로그래밍을 할 경우 user2가 생긴다면 비효율적인 코드를 짜게 된다.
그래서 이렇게 서로 연관이 있는 데이터들을 하나로 묶어, namespace 처럼 관리할 수 있는 방식을 생각하게 된다.

### struct(구조체)의 등장
```text
struct Character {
    char name;
    int hp;
    int mp;
};
```
의미 있는 단위로 변수들을 하나로 묶음으로써, 변수명의 중복을 줄이고 함수나 배열 등에서도 하나의 변수처럼 활용할 수 있게 되었다.
코드의 덩치가 커져도 일관성을 유지하면서 코드를 짤 수 있게 된 첫 걸음인 셈이다.

### 객체지향 프로그래밍의 등장
구조체가 등장하면서 전역에 뿌려져 있던 변수들을 하나로 묶어 처리하다 보니,  
시스템의 동작을 우선으로 코딩하는 것보다 **데이터를 중심으로 코딩하게 되면 코드의 덩치가 커져도 일관성을 유지하기 좋다는 사실**을 깨닫게 되었다.

하지만 구조체에는 변수만 담을 수 있었고 함수들은 여전히 prefix를 통해서 구분해야 했었는데, 이 또한 하나로 합쳐서 관리하고 싶어지게 되었다.

그래서 함께 자주 쓰이는 변수와 함수들을 하나로 묶어서 관리하는 개념을 만들었고 그것이 `Class`이다.
```text
class Character {
    char name;
    int hp;
    int mp;
    
    attack();
    skill();
}
```

이렇게 `Class`가 등장하고, 기존의 데이터와 처리방법을 분리해서 개발하던 절차식 프로그래밍과 달리 데이터의 처리 방식이 하나의 모듈로 관리되게 되면서,
마치 작은 프로그램들이 독립적으로 돌아가는 형태를 띄게 되었다.(컴포넌팅)











