# [Next] 서버 컴포넌트

## 서버 컴포넌트의 등장배경
Page Router에서는 사전 렌더링 과정을 거치며 유저에게 화면이 띄워진다.

이때 hydration을 하기 위해서 Page Router 방식에서는 js 번들로 모든 컴포넌트가 묶여서 client 측에 전달 된다.
하지만 react hooks나 event handler가 없는 상호작용 기능이 없는 컴포넌트들은 js 번들에 담길 필요가 없다.

앞서 말했듯이 Page Router 버전에서는 client 전달 되지 않아도 되는 모든 component들이 js 번들로 담기게 되니까 js 번들을 불러오는데 시간이 오래 걸릴수도 있게 된다.
이는 상호작용이 가능한 TTI 까지의 시간이 길어진다는 것으로도 말할 수 있어 성능에 좋지 않다.

서버 컴포넌트는 서버측에서 사전 렌더링을 진행할 때 딱 한번만 실행이 된다.
클라이언트 컴포넌트는 사전 렌더링을 진행할 때 한번, hydration을 진행할 때 한번 총 2번 실행 된다.

그렇기 때문에 Next 공식 문서에서는 기본적으로는 서버 컴포넌트 base로 코드를 작성하되, 필요한 경우에만 클라이언트 컴포넌트를 사용할 것을 권장하고 있다.
(app router에서는 기본적으로 서버 컴포넌트로 작성하게 되어있어 클라이언트 컴포넌트로 쓰고 싶다면 'use client'라고 명시를 해주어야 한다.)


## 서버 컴포넌트 주의사항
### 서버 컴포넌트에서는 client에서 실행되어야 하는 코드가 있어선 안된다.
onclick, keyup등의 상호작용을 담당하는 Event Handler나 useEffect 같은 hooks가 담기면 안된다.
또한 어떤 라이브러리가 client 측에서 실행되는 코드를 지닌다면 지양해야 한다.

### 클라이언트 컴포넌트는 2번 실행된다.
이말은 즉 클라이언트 컴포넌트는 클라이언트 에서만 실행되는 것이 아니라 서버, 클라이언트 2곳에서 실행된다.
사전 렌더링을 위해 서버에서 1번, 하이드레이션을 위해 브라우저에서 1번 실행된다.

### 클라이언트 컴포넌트에서는 서버 컴포넌트를 import 할 수 없다.
클라이언트 컴포넌트는 서버와 클라이언트 2곳에서 실행이 되어야 하는데 서버 컴포넌트는 클라이언트 컴포넌트 내에 내포되어 있다고 해도 1번 밖에 실행이 되지 않는다.
그래서 브라우저에서 코드가 실행될때 js 번들 내에 서버 컴포넌트가 없다보니 에러가 발생하게 될 가능성이 생기게 된다.

다만, Next는 개발자의 편의를 위해 위와 같이 에러가 발생할 상황일때 서버 컴포넌트를 클라이언트 컴포넌트로 바꿔주기도 한다.

어쩔수 없이 위와 같이 서버 컴포넌트를 클라이언트 컴포넌트에서 사용해야 할 경우
서버 컴포넌트를 클라이언트 컴포넌트에서 바로 import 하지 말고 children을 렌더링 하도록 하면 불필요하게 js 번들내에 담기지 않게 된다.

### 서버 컴포넌트에서 클라이언트 컴포넌트에게 직렬화 되지 않는 Props는 전달 불가하다.
> 직렬화(Serialization): 객체 배열 클래스 등의 복잡한 구조의 데이터를 네트워크 상으로 전송하기 위해 아주 단순한 형태(문자열, Byte로 변환 하는것)  
ex) `json.stringify` 처럼 객체를 문자화하는 것이라 생각하면 이해가 쉽다.

함수와 같은 경우는 js 내에서 실행환경, lexical scope 등의 기능을 지녀서 직렬화가 불가능하다.
이렇게 직렬화가 불가능 한 경우는 props로 전달이 안된다.

왜? 유저로 부터 접속요청을 받고 사전 렌더링 되는 과정을 보면 알 수 있다.
사전렌더링을 진행할때는 서버, 클라이언트를 막론하고 모든 컴포넌트들이 전부 렌더링이 된다.
하지만, 이러한 과정에서도 순서가 나뉘어 진다.

![image (2).png](..%2F..%2F..%2FDownloads%2Fimage%20%282%29.png)

서버 컴포넌트들은 RSC payload 형태로 먼저 직렬화가 되고 그 후 실행되지 못한 클라이언트 컴포넌트 들이 마저 실행되어서 html 구조를 형성하게 된다.
이 서버 컴포넌트들을 직렬화 하는 과정에서 함수들은 직렬화가 될 수 없기 때문에 클라이언트 컴포넌트에게 props로 내려주지 못한다.
그렇기에 runtime 에러가 발생하게 된다.

#### RSC Payload
> RSC Payload는 React Server Component의 순수한 데이터(결과물)를 의미한다.  
> 이는 즉, RSC를 직렬화 한 결과를 말한다.

RSC Payload에는 서버 컴포넌트의 모든 데이터가 포함된다.
- 서버 컴포넌트의 렌더링 결과
- 연결된 클라이언트 컴포넌트의 위치
- 클라이언트 컴포넌트에게 전달하는 값