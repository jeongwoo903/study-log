# [CS] 웹 보안의 흐름

## 쿠키
클라이언트가 웹에 접근할때 정보를 저장하는 일련의 기록파일
key: value -> object 형태로 정보를 저장함
주로 ip, mac 접속자를 특정할 수 있는 정보를 저장함.

한 쿠키당 4k 정도 함.
4k 보다 넘는다면 연결시켜서 저장하기도 함.

브라우저마다 쿠키 종류가 다름.

정보 저장을 목적으로 사용.
-> request 정확하게 보내주기 위해서..?

유저 정보들을 모조리 쿠키에다 담았음
그러다 보니 보안에 취약하게 됨. 또한 인증이 필요한 요청을 하게 되면 매번 인증을 해야함.
그러다 보니 서버에 부하가 걸리게 됨.

쿠키가 털리게 되면 쿠키를 조작할 수 있기 때문에 문제가 됨.

이러한 문제를 해결하기 위해 'session'이 나오게 됨.

## session
서버 단에서 특정 세션 저장소를 만듬.
세션의 id를 반환해주면 인증이 됨.

쿠키는 유저 개인정보를 모조리 다 담았는데 이를 막기 위해 개인 민감 정보 노출을 방지하기 위해 나오게 됨.

1. 로그인
2. 서버에서 세션생성 -> 응답(세션 id)
3. 클라이언트 쿠키 생성
4. 인증단계
   - 클라이언트 쿠키를 서버에 전달
   - 서버 쿠키 해체 -> 세션 저장소 확인
   - 응답 반환

여전히 보안의 문제는 있음.
쿠키와 세션을 동시에 쓰기 때문에 쿠키가 탈취당할 위험이 있음.

세션의 장점은 저장소를 따로 관리한다는 점임.
세션 id가 탈취 당하면, 저장소를 비워버리면 됨.

저장소가 문제가 생기면 응답하는데 오류가 발생함.

-> http는 상태가 없음.(stateless)
세션이랑 같이 쓰면 statefull 해짐

-> statefull의 문제 
서버를 증설하고 싶을때 정보가 중복된다는 문제가 생김.
세션 스토리지를 만들어야 하는데 귀찮음.

-> 요청의 문제
인증이 필요한 요청을 하게 되면 매번 인증을 해야함.

---

## jwt의 등장

현재 jwt는 인터넷 표준임.

json을 뭘 담을까.
인증에 필요한 정보를 담음.

jwt토큰이 동작 하는 방식은 쿠키랑 별 다르지 않음.
- 쿠키와의 제일 다른점 = 서명을 한다.

RSA 인증방식
공개 / 개인키

---

단방향 암호화는 암호화만 됨. ex) 비밀번호
양방향은 암호화 복호화 둘다 됨 ex) 서명할때

양방향을 쓰는 이유는 데이터 무결성 때문에.
단방향을 쓰는 이유는 절대 풀리면 안되기 때문에.

---

대칭키 / 비대칭키 
대칭키는 같은 키로 연산 속도가 빠름.
비대칭키는 다른 키로 보안이 좀 더 튼튼함. 복잡한 암호화 방식이 필요.

---

SSL는 세션키를 만듬
비대칭키로 암호화를 함. - 비대칭키를 씀.
데이터를 전송할때는 대칭키를 씀.

---
## jwt의 구조

xx.yy.zz

1. xx - 헤더
- 타입
- 서명을 할때의 알고리즘
2. yy - 페이로드
- iss
- subject 제목
- audience 대상자
- expiration 만료시간
- nbf 토큰의 활성 날짜
- iat 
- jti
- 보안에 민감한 자료가 아닌 전달하고 싶은 정보  
3. zz - 시그니처
- base64로 인코딩된 암호키
- 서버에 있는 개인키로 풀 수 있음.

jwt는 무적이 아니다.
- 클라이언트에서는 뭘해서도 풀수 없음. 

## jwt의 단점
- base64 인코딩은 전달 문자가 길어져버림.
- 여전히 payload의 민감 정보가 담길 수 있음.  
- 탈취 당하면 대처하지 못함.
  - 그래서 만료시간을 짧게 함.
  - access token의 만료시간은 짧게
  - refresh token의 만료시간은 길게
- stateless를 잘지켜서 상태가 없음.
- sliding session 
  - 특정 서비스를 사용하고 있는 유저에 대해서 만료 시간을 길게 늘려줌.

쿠키를 보낼때 3단위로 짤라 보내는데
http-only가 세팅되어 있지 않다면..

cookie에 jwt를 담아서 쓰거나
req.header에 담아서 쓰거나
Authorization에 담아서 쓰거나.