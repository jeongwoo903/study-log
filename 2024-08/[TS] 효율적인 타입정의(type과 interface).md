# [TS] 효율적으로 타입을 정의하는 방법은 뭘까?

## 서론
typescript는 javascript의 **동적 타이핑(타입 추론)으로 인한 문제**와 **개발 환경에서 타입으로 인한 에러를 방지하기 위해 등장**하게 되었다.  
이러한 관점에서 보았을때 그럼 모든 변수들과 객체들은 명시적으로 타입을 지정해주어야 하나? 싶은 생각이 들었다.  

## 모든 변수들과 객체들에 대해서 타입을 지정해주는 것이 좋지 않나?

### 일반적인 경우
모든 변수와 객체에 타입을 명시적으로 지정하는 것은 코드의 가독성과 유지 보수성을 높일 수 있다.
잠재적인 에러를 방지하는 데 도움이 된다.
```typescript
let userName: string = "John";
let userAge: number = 25;
```

### 타입 추론의 장점
하지만 TypeScript는 강력한 타입 추론 기능을 제공하기 때문에 모든 변수에 명시적으로 타입을 지정할 필요는 없다.  
예를 들어, 다음과 같은 코드에서는 TypeScript가 userName이 string 타입임을 자연스럽게 추론할 수 있습니다.  
```typescript
let userName = "John"; // TypeScript가 자동으로 userName을 string 타입으로 추론한다.
```
이렇게 타입 추론을 활용하면 코드가 간결해지면서도 타입 안전성을 유지할 수 있다.  
특히 타입이 명확할 때는 타입을 생략하는 것이 코드의 가독성을 높이는 데 도움이 된다.  

### 그럼 언제 타입을 지정하는게 좋을까?
따라서 모든 변수에 타입을 명시적으로 지정하기보다는, **타입 추론이 불명확**하거나 **코드의 의도를 명확히 하고 싶을 때**에만 타입을 명시적으로 지정하는 것이 더 좋은 전략이다.   

아래와 같은 경우에는 타입을 명시적으로 지정하는 것이 유리할 수 있습니다.  
- 함수의 반환 타입을 명확히 할 때.  
- 복잡한 객체나 배열의 구조를 명확히 하고자 할 때.  
- 제네릭 타입을 사용하는 경우.

즉, 결론적으로 **모든 경우에 타입을 명시적으로 지정할 필요는 없다.**  

## 타입을 효율적으로 정의 하는 법
### 실제 오류가 난 위치를 명확하게 파악가능하게 정의해야 한다.  
![스크린샷 2024-08-13 오전 1.39.35.png](..%2F..%2F..%2FDesktop%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-08-13%20%EC%98%A4%EC%A0%84%201.39.35.png) | ![스크린샷 2024-08-13 오전 1.39.54.png](..%2F..%2F..%2FDesktop%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-08-13%20%EC%98%A4%EC%A0%84%201.39.54.png) |
--- | ---|

왼쪽 사진과 같이 Person 타입을 파라미터로 받는 Student라는 함수가 있다고 하자.  
이때 오른쪽 사진과 같이 jeongwoo를 객체 리터럴로 선언하고 인자로 넣으면 typescript의 타입 추론으로 인해 `{id: string; name: string}` 이라고 에러가 난다.  

하지만 명확히 휴먼 에러가 난 곳을 따지자면 파라미터를 잘못 넣은 것이 아니라 객체를 만들때 타입에 맞지 않는 값을 넣었다는 것이다.  
![스크린샷 2024-08-13 오전 1.41.00.png](..%2F..%2F..%2FDesktop%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-08-13%20%EC%98%A4%EC%A0%84%201.41.00.png)

이처럼 만약 객체 리터럴을 선언할때 타입을 선언해 주었다면 보다 명확히 수정이 필요한 곳에서 에러가 발생하는 것을 볼 수 있다.  

함수도 마찬가지이다.  
![스크린샷 2024-08-13 오전 2.08.21.png](..%2F..%2F..%2FDesktop%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-08-13%20%EC%98%A4%EC%A0%84%202.08.21.png)

`getUserData()` 함수는 Promise 객체를 반환하길 희망하지만, userData가 존재한다면 이에 가로막혀 string을 반환하고 만다.  
함수를 실행시키는 부분을 보면 `then`을 호출할 수 없는데 타입이 맞지 않아서 그렇다.  
![스크린샷 2024-08-13 오전 2.15.10.png](..%2F..%2F..%2FDesktop%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-08-13%20%EC%98%A4%EC%A0%84%202.15.10.png)

만약 반환 타입을 제대로 명시해 주었다면 if문 내의 `userData`의 return 타입이 잘못 되어서 문제가 된다는 것을 쉽게 알 수 있다.  
즉, 문제가 일어나는 지점을 명확히 할 수 있다.

### 직관적으로 타입을 알 수 있도록 해야 한다.
![스크린샷 2024-08-13 오전 2.49.04.png](..%2F..%2F..%2FDesktop%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-08-13%20%EC%98%A4%EC%A0%84%202.49.04.png)
`getUser()`은 간단히 정보를 받아서 객체 형태로 반환해주는 함수이다. typescript는 함수를 파악해 위의 사진과 같이 반환되어야 할 객체의 타입을 추론해준다.  

하지만 코드가 복잡해질수록 위와 같은 형태는 시각적으로 보기 불편해질 것이다.
![스크린샷 2024-08-13 오전 2.50.05.png](..%2F..%2F..%2FDesktop%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-08-13%20%EC%98%A4%EC%A0%84%202.50.05.png)
우리가 원하는 반환 값이 타입이 `User`라는 타입이라면, 다음과 같이 반환 값의 타입을 지정해준다면 typescript는 우리의 의도대로 타입을 명시해줄 것이다.

결론적으로, 직관적으로 타입을 알 수 있고 오류가 난 곳을 명확하게 나타낼수 있도록 타입을 명시하는 것이 좋은 DX(Developer Experience)를 만들어내는 결과로 이어질 것 같다.






