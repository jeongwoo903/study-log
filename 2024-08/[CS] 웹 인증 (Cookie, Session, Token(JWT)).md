# [CS] 웹 인증 (Cookie, Session, Token(JWT))

## 선 개념
- [[HTTP] http의 특징](https://github.com/jeongwoo903/study-log/blob/main/2024-08/%5BHTTP%5D%20http%EC%9D%98%20%ED%8A%B9%EC%A7%95.md)

## 초기 웹의 문제점
초기 웹에서는 http 방식을 사용했기 때문에, 사용자의 요청에 대한 상태를 기억할 방법이 없었다. 
왜냐면 http는 서버가 각 요청을 독립적으로 처리하고 상태를 저장하지 않는 stateless적인 특징을 띄었기 때문이다.  

이로 인해서 웹에서 사용자의 상태를 관리하는데 어려움이 있었다.
예를 들면, 사용자가 쇼핑몰 사이트에 물품을 추가했는데, 상태가 유지가 안되다 보니 다음 페이지로 넘어갔을때 추가된 물품이 없어진다고 생각하면 된다.  

## 쿠키(Cookie)의 등장
> 📌 쿠키(Cookie): Client에서 작은 데이터 파일을 저장해, 사용자의 상태를 유지하고 관리하는 기록파일이다.  

그래서 이러한 불편함을 해소하기 위해 Cookie라는 개념이 등장하였다.

쿠키는 key-value의 형태로 사용자의 정보를 담을 수 있다.
```html
HTTP/1.1 200 OK
Set-Cookie: theme=black; HttpOnly; Path=/; Secure; SameSite=Strict
Content-Type: text/html

<!DOCTYPE html>
<html>
    <head>
        <title>Home</title>
    </head>
    <body>
        <h1>Welcome to Home Page</h1>
    </body>
</html>

```

쿠키가 나오고 나서 사용자의 상태를 Client에 저장해 요청을 보낼 수 있게 되어서 상태를 유지할 수 있게 되었다.
하지만 상태를 유지할 수 있다는 장점이 생겼지만, 한계점 또한 존재했다.

인증이 필요한 웹의 경우 사용자의 상태를 확인하기 위해 매번 인증을 해야했는데, 그러다 보니 서버에 부하가 걸리게 된다는 단점이 있다.

쿠키는 주로 사용자 정보, 사용자 설정, 인증 정보등 다양한 형태의 정보들을 저장할 수 있다.  
그러다 보니 **민감한 정보들을 담기는 문제**들이 있기도 하였다.
하지만 쿠키는 **일반적으로 최대 4KB 정도의 데이터를 저장**할 수 있기 때문에 저장할 정보를 잘 생각해야 한다.
(쿠키를 3개로 나누어 12kb의 정보를 저장하기도 한다고 한다..)

유저 정보를 쿠키로 관리하다 보니 보안에 취약할 수 밖에 없었고, 한 번 쿠키가 털리게 되면 쿠키를 조작되어 사용될 경우도 있었다.

## 세션(Session)의 등장
> 📌 세션(Cookie): 사용자의 상태 정보를 서버에서 저장하기 위한 매커니즘.

세션은 쿠키의 한계(특히 보안과 크기 제한)를 극복하기 위해 도입된 서버 측 상태 관리 방식이다.  

쿠키가 사용자의 정보를 Client에 저장하였다면, 세션은 서버 측에 저장한다.  
서버에서 특정 세션 저장소를 만들어 사용한다.

정보가 서버에 있기 때문에 사용자 정보를 얻고 싶다면 서버에 요청을 해야하는데, 이때 **Session ID**를 쿠키에 저장하여 이용한다.  
Session ID는 서버에서 생성된 고유한 식별자로, 클라이언트와 서버 간의 상태를 연결하는 역할을 한다.  

세션은 서버 측에 정보를 저장해두었기 때문에 쿠키보다 탈취·조작 당할 위험성이 적다.  
만약 Session ID를 탈취당한다 하더라도 서버의 세션 저장소를 비워버리면 정보는 공개되지 않을 수 있다.
하지만 쿠키와는 달리 서버에 문제가 생기면 정보를 가져오지 못한다는 리스크가 있기도 하다.

세션을 쓰면 고려해야 할 점이 있는데 바로 http의 무상태성(stateless)이 상쇄 된다는 점이다.
http는 상태를 저장하지 않는데 세션을 쓰면 상태를 저장하는 꼴이 되기 때문에 상태가 유지(stateful)되게 된다.

stateful하게 된다는 것이 문제가 문제가 된다는 것은 아니다.
하지만 http의 원래의 기능을 의도적으로 무시하는 것이기 때문에 장점과 단점에 대해 알아두어야 한다.

### 세션 사용의 트레이드오프
세션을 사용하면 http의 무상태성을 상쇄하지만, 다음과 같은 이점을 얻을 수 있다.
1. 상태를 유지할 수 있다.
   - 상태 기반의 기능을 제공할 수 있다.
2. 보안이 강화된다.
   - 정보를 서버에 저장하기 때문.

하지만 다음과 같은 문제점이 생긴다.
1. 서버 확장성 문제
    - 서버를 증설할때 해당 세션 정보를 어느 서버에서 저장해둘건지 고려해야 한다.  
    http의 경우 상태를 저장하지 않았기 때문에 아무 서버에 요청을 해도 동일한 응답을 할 수 있었지만, 세션을 사용할 경우 모든 서버에 동일한 세션을 담고 있어야 이가 가능해진다.  
    - 각 서버에 동일한 세션을 유지시키는 것은 서버간 트래픽이 증가하게 된다. A서버가 요청으로 인해 세션 정보가 바뀌면 B, C 등 다른 서버도 동일하게 정보를 유지해야 하기 때문이다.  
    - 세션을 공유하는 중앙 집중식 세션 저장소를 만들면 데이터 중복의 문제는 해결될 수 있겠지만, 요청이 많아질시 병목현상이 생길 수도 있다.  
2. 잦은 인증 요청
    - 쿠키를 사용할 때와 동일하게 인증 상태를 확인 하기 위해서는 인증이 필요한 순간마다 Session ID를 서버에 전송해야 한다.  

## JWT(Json Web Token)의 등장
> 📌 JWT(Json Web Token): 토큰 자체에 사용자 정보를 저장하여, 상태를 서버에 저장하지 않고도 인증을 관리할 수 있는 인증 방식이다.

세션는 서버의 확장성, 자원, 세션 하이재킹 등과 같은 한계가 있었고 이를 극복하기 위해 JWT가 등장하였다.   

JWT는 인증 정보와 클레임(Claims)을 포함한 토큰이다.  
(클레임이란 JWT(JSON Web Token)에서 사용자에 대한 정보나 토큰의 속성을 나타내는 데이터 조각을 말한다. 클레임은 JWT의 페이로드(Payload) 부분에 포함되며, 토큰이 인증된 사용자에 대한 다양한 정보를 전달하거나, 토큰의 동작 방식을 제어하는 데 사용된다.)

토큰은 2가지의 토큰을 통해 인증을 구현한다. JWT도 이러한 매커니즘을 따른다.
1. Access Token
   - 실제로 권한을 담당하는 토큰이다.
   - 짧은 만료시간을 통해 탈취 당하더라도 안전하도록 설계한다. 이 경우 Refresh 토큰을 통해 갱신할 수 있도록 한다.
2. Refresh Token
   - Access Token을 갱신 할 때 사용하는 토큰이다.
   - Access Token을 갱신 할 수 있는 토큰이기에 Access Token 보다 더 높은 보안을 요구한다.
   - 주로 긴 만료시간을 가지고 있다.

쿠키와 JWT의 가장 큰 차이점은 **서명(Signature)을 한다는 점**이다.
(서명이란 **특정 데이터에 대해 생성된 고유한 코드**로, 해당 데이터가 변조되지 않았고, 신뢰할 수 있는 주체에 의해 생성되었음을 증명하는 역할을 한다.)  

세션과는 달리 JWT는 http의 무상태성(stateless)를 해치지 않는다.
서버는 JWT를 저장하거나 관리할 필요가 없으며, 매 요청마다 JWT를 받아 검증하여 사용자를 인증한다. 이를 통해 서버의 확장성을 높일 수 있다.

### JWT의 구조
JWT는 **헤더(Header), 페이로드(Payload), 서명(Signature)**의 세 부분으로 구성 되어있다.
이 3개의 부분은 모두 base64로 인코딩 되어 있으며 각 부분은 .으로 이루어져 있다.

1. 헤더(Header)
- 헤더에는 JWT의 타입과 서명을 할때의 알고리즘이 담긴다.
```json
{
  "alg": "HS256",
  "typ": "JWT"
}

```

2. 페이로드(Payload)
- 페이로드는 클레임(Claims)을 담고 있는 부분으로, 사용자 정보와 추가적인 데이터를 포함할 수 있다.
```json
{
   "sub": "1234567890",
   "name": "Jang Jeongwoo",
   "admin": true,
   "exp": 1609459200,                                                                                 
}

```

3. 서명(Signature)
- 서명은 헤더와 페이로드를 결합하고, 비밀 키를 사용해 서명한 값이다. 이 서명을 통해 JWT의 무결성과 진위 여부를 확인할 수 있다.
- 서버에 있는 개인키로만 풀 수 있다.

```js
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```

세션의 단점을 보완하면서 나오게된 JWT도 단점은 존재한다.

1. base64 인코딩을 하기 때문에 문자열의 길이가 길어져버린다. 
2. JWT는 많은 정보를 포함할 수 있기 때문에, 토큰 크기가 커질 수 있다.
3. JWT는 인코딩된 상태로 전송되지만, 누구든지 JWT를 디코딩하여 내용을 확인할 수 있으므로, 민감한 정보가 페이로드에 담긴다면 문제가 될 수도 있다.

---

이외에도 공개키/비공개키, RSA 등 연관된 다양한 개념들이 있으니 한 번 알아보자!









