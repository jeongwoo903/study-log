# [1장] 리액트는 진화중이다

## 목차
- [리액트의 목표](#리액트의-목표)
- [상태(state)](#상태(state))
- [컴포넌트 유형 이해하기](#컴포넌트-유형-이해하기)
- [hook](#hook)
  * [상태가 있는 함수 컴포넌트](#상태가-있는-함수-컴포넌트)
  * [함수 컴포넌트의 장점](#함수-컴포넌트의-장점)
  * [custom hook](#custom-hook)
  * [third-party hook](#third-party-hook)
- [동시 렌더링과 Suspense](#동시-렌더링과-Suspense)
- [리액트 새 코드 공개 채널](#리액트-새-코드-공개-채널)

## 리액트의 목표
리액트의 목표는 컴포넌트 개발을 쉽게 하면서, 재사용 하기 쉬운 인터페이스로 합성할 수 있게 하는 것이다.  
즉, 리액트는 컴포넌트의 생성과 합성을 쉽게 해준다.

> **[생각] 좋은 컴포넌트를 설계하는 법 1**  
> "공통 속성 뽑아내기"

## 상태(state)
컴포넌트의 상태 중 어떤 값이 변경되면 UI를 다시 렌더링 한다.
```text
유저의 여러번의 상태 변경  
   ↓
최종 상태 반영
   ↓
변경 발생
```

## 컴포넌트 유형 이해하기
리액트는 함수 컴포넌트와 클래스 컴포넌트가 있다.  
(함수형 컴포넌트와 함수 컴포넌트는 다르다. 하지만 상태가 없다면 어떤 의미에서는 함수형이라 할 수 있다.)

클래스 컴포넌트의 경우 다음과 같은 구조를 띈다.
```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    
    this.state ={
      // 여기서 상태를 설정
    }
  }
  
  componentDidMount() {
    // 데이터 적재 및 Side Effect 처리
  }
  
  render() {
    // props에 따른 UI 반환
  }
}
```
hook을 사용한다는 것은 이제부터 함수 컴포넌트를 이용해 상태와 Side Effect를 관리하겠다는 뜻이다
```jsx
 function MyComponent(props) {
  const [value, setValue] = useState(initalValue);
  const [state, setState] = useReducer(reducer, initalState);
  
  useEffect(() => {
    // Side Effect 처리
  })
  
  return (
    // 함수가 UI를 직접 반환
  )
}
```

## hook
hook을 사용하면 
- 함수 컴포넌트에 상태를 추가할 수 있다. 
- 깔끔하게 부수 효과를 캡슐화 할 수 있다.
- 프로젝트 전반에 걸쳐 코드를 재사용할 수 있다.  

또한
- 클래스의 필요성이 줄어든다.
- 우아한 방식으로 코드의 크기를 줄이고 개선할 수 있다.

### 상태가 있는 함수 컴포넌트
> JS에서 함수는 함수를 내포할 수 있다.

> **[생각] 좋은 컴포넌트를 설계하는 법 2**  
> "적은 코드와 조직화된 코드(필요한 로직이 잘 뭉쳐진 코드)"

이 점은 함수 컴포넌트의 장점인데 이 때문에 이벤트 핸들러를 포함할 수도 있다.  
또한 컴포넌트 안에서 Side Effect를 쉽게 캡슐화 할 수 있다.


### 함수 컴포넌트의 장점
- **코드 양이 더 적다.**
- **관련 코드를 함께 유지하면서 코드를 정리할 수 있기 때문에 코드를 더 잘 조직화 할 수 있다.**
- **특징을 외부 함수로 추출해서 공유하고 재사용할 수 있다.**
- 더 쉽게 컴포넌트를 테스트 할 수 있다.
- 클래스 생성자에서 super()를 호출 할 필요가 없다.
- this를 다루거나 핸들러를 바인딩할 필요가 없다.
- 생명 주기 모델이 더 단순하다.
- **상태가 핸들러, 부수 효과 함수, 반환된 UI등의 영역 안에 지역적으로 존재한다.**

클래스 컴포넌트를 사용하면 상태를 생성자 함수 안에서 설정하고, 이벤트 핸들러를 this에 바인딩시켜야 하며, 부수 효과 코드는 **여러 가지 생명 주기 매서드(componentDidMount, componentWillUnmount, componentWillUpdate 등)** 사이에 나뉘어 들어가야 한다.

| ![1.jpeg](assets/1%EC%9E%A5/1.jpeg) |
|:-----------------------------------:|
|      클래스 컴포넌트와 함수 컴포넌트 비교           |

### custom hook
함수 컴포넌트는 서로 연관된 Side Effect 로직을 한 곳에 유지하도록 권장한다.  
Side Effet가 여러 컴포넌트에 필요한 기능이라면 조직화를 한 단계 더 진행해서, 코드를 추출해 외부 함수를 만들 수 있다.
이를 **custom hook** 이라 한다.

|  ![2.jpeg](assets/1%EC%9E%A5/2.jpeg)  |
|:-------------------------------------:|
|           커스텀 훅을 이용한 코드 조직화           |


> 커스텀 훅으로 추출할 수 있는 다양한 작업에 대한 감을 잡을 수 있는 사이트  
> https://usehooks.com/

### third-party hook

- 리액트 라우터
- 리덕스
- 리액트 스프링(애니메이션 관련)

## 동시 렌더링과 Suspense
두 기능은 비동기 프로세스를 더 잘 관리할 수 있고 더 부드럽고 반응성이 좋은 사용자 경험을 제공할 수 있게 해준다.
(이와 관련된 내용은 따로 정리)

## 리액트 새 코드 공개 채널
리액트 팀은 코드를 분리된 채널을 통해 공개한다.
- 최종(Latest): 안정적인 시앤틱 버전 배포
- 다음(Next): 리액트 개발의 메인 브랜치를 따라감
- 실험적(Experimental): 실험적인 API나 기능을 포함함

> 최근 React 19에 대해서 나옴  
> https://react.dev/blog/2024/12/05/react-19









